// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: orders.sql

package sqlgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkCancelOrders = `-- name: BulkCancelOrders :many
UPDATE orders
SET status     = 'cancelled',
    updated_at = NOW()
WHERE id IN (SELECT id
             FROM orders
             WHERE status = 'pending'
               AND expired_at < NOW()
             LIMIT $1)
RETURNING id, category_id, name, email
`

type BulkCancelOrdersRow struct {
	ID         int32
	CategoryID int16
	Name       string
	Email      string
}

func (q *Queries) BulkCancelOrders(ctx context.Context, limit int32) ([]BulkCancelOrdersRow, error) {
	rows, err := q.db.Query(ctx, bulkCancelOrders, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BulkCancelOrdersRow
	for rows.Next() {
		var i BulkCancelOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrderByEmailAndStatusPending = `-- name: FindOrderByEmailAndStatusPending :one
SELECT EXISTS (SELECT 1
               FROM orders
               WHERE email = $1
                 AND status = 'pending') AS "exists"
`

func (q *Queries) FindOrderByEmailAndStatusPending(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, findOrderByEmailAndStatusPending, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const findOrderByExternalIdAndStatusPending = `-- name: FindOrderByExternalIdAndStatusPending :one
SELECT id,
       category_id,
       external_id,
       name,
       email,
       phone,
       payment_code,
       expired_at
FROM orders
WHERE external_id = $1
  AND status = 'pending'
`

type FindOrderByExternalIdAndStatusPendingRow struct {
	ID          int32
	CategoryID  int16
	ExternalID  string
	Name        string
	Email       string
	Phone       string
	PaymentCode string
	ExpiredAt   pgtype.Timestamp
}

func (q *Queries) FindOrderByExternalIdAndStatusPending(ctx context.Context, externalID string) (FindOrderByExternalIdAndStatusPendingRow, error) {
	row := q.db.QueryRow(ctx, findOrderByExternalIdAndStatusPending, externalID)
	var i FindOrderByExternalIdAndStatusPendingRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.ExternalID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.PaymentCode,
		&i.ExpiredAt,
	)
	return i, err
}

const insertOrder = `-- name: InsertOrder :one
INSERT INTO orders(category_id, external_id, name, email, phone, payment_code, expired_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type InsertOrderParams struct {
	CategoryID  int16
	ExternalID  string
	Name        string
	Email       string
	Phone       string
	PaymentCode string
	ExpiredAt   pgtype.Timestamp
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertOrder,
		arg.CategoryID,
		arg.ExternalID,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.PaymentCode,
		arg.ExpiredAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateOrderStatusToCompleted = `-- name: UpdateOrderStatusToCompleted :execresult
UPDATE orders
SET status     = 'completed',
    updated_at = NOW()
WHERE id = $1
  AND status = 'pending'
`

func (q *Queries) UpdateOrderStatusToCompleted(ctx context.Context, id int32) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateOrderStatusToCompleted, id)
}

const updateOrderTicketRowCol = `-- name: UpdateOrderTicketRowCol :execresult
UPDATE orders
SET ticket_row = $1,
    ticket_col = $2
WHERE id = $3
  AND status = 'completed'
`

type UpdateOrderTicketRowColParams struct {
	TicketRow pgtype.Int4
	TicketCol pgtype.Int4
	ID        int32
}

func (q *Queries) UpdateOrderTicketRowCol(ctx context.Context, arg UpdateOrderTicketRowColParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateOrderTicketRowCol, arg.TicketRow, arg.TicketCol, arg.ID)
}
